#! /bin/bash

# This script will create archives with OS, Adapter and CUDBG logs
# use -h/--help to print help messages.
# =================================================================

VERSION=1.0

PWD=$(pwd)
kver=$(uname -r)
distro=$(cat /etc/*-release)
arch=$(uname -p)

args=("$@") 
cmd_args=${#args[@]} 
arg_stat=0
myname=$(basename $0)
fbusid=""
global_print_once=""
cudbgmbox=6
cudbgpayload=""
declare -A toe

function handle_interrupt
{
	kill -SIGTERM 0
	wait
}

trap handle_interrupt SIGINT SIGTERM

if [[ $cmd_args -ne 0 ]] ; then
	for (( i=0;i<$cmd_args;i++)); do 
		if [[ ${args[${i}]} == "-h" ]] || [[ ${args[${i}]} == "--help" ]]; then
			echo -e "\n${myname} v${VERSION}\n------------------\n"
			echo "Execute this script with root privilages to collect chelsio debug logs"
			echo -e "./$myname"
			echo -e "-b <bus id>\t - Provide bus id, format: 01:00.4 or 0000:01:00.4"
			echo -e "\n-c <mbox>\t - Cudbg mailbox number (0-6) from which to collect cudbg logs. Default 6."
			echo -e "\n--getpayload\t - Collect Payload Data in EDC and MC."
			echo -e "\n-h,--help\t - Print help"
			echo -e "\nThe ${myname} script will collect Chelsio debug information and creates a archive.\n"
			exit 0
		elif [[ ${args[${i}]} == "-b" ]];then
			i=$((i + 1))
			if [[ $i -ge $cmd_args ]];then
				echo -e "\n\tWrong Input\n"
				exit 0
			fi
			fbusid=${args[${i}]}	
			if ! [[ $fbusid =~ ^0000.* ]]
			then
				fbusid=0000:$fbusid
			fi
			fbusid=${fbusid%.*}.4
		elif [[ ${args[${i}]} == "-c" ]];then
			i=$((i + 1))
			if [[ $i -ge $cmd_args ]]; then
				echo -e "\n\tWrong Input\n"
				exit 0
			fi
			cudbgmbox=`expr ${args[${i}]} + 0`
			if [[ -z $cudbgmbox ]] || [[ $cudbgmbox -gt 6 ]]; then
				cudbgmbox=6
			fi
		elif [[ ${args[${i}]} == "--getpayload" ]];then
			cudbgpayload="--getpayload"
		else
			echo "Invalid argument specified, Please use --help for more information."
			exit 1
		fi
	done
fi

if [[ $EUID -ne 0 ]] ; then
	echo "Please execute this script with root privilages, use --help for more information."
	exit 1
fi

proc_sys=/proc/sys
offload_devices_Path=/proc/net/offload/devices
logdir_name=IBM_chelsio_debug_logs
logdir=${PWD}/$logdir_name
debugfs_dir=$logdir/debugfs
toe_dir=$logdir/toe
qdesc_dir=$logdir/qdesc
logfile=${logdir}/chelsio_debug.log
cudbgdir=${logdir}/cudbg
cudbglog=${cudbgdir}/cudbg
debugfs_path=/sys/kernel/debug
ch_debugfs=$debugfs_path/cxgb4

if [ -d $logdir ] ; then
	old_dir=${logdir}_old
	mkdir -p $old_dir
	mv $logdir $old_dir/$(date '+%d_%b_%Y_%H_%M_%S')
fi
mkdir -p $logdir $cudbgdir $toe_dir $debugfs_dir

function header
{
	clear
	echo "************************************"
	echo "    Chelsio Debug Collector v${VERSION}"
	echo "************************************"
}

declare -a fbuspath
bus_ids=$(lspci -D | grep -i -e '00\.4.*Chelsio'| awk '{print $1}')
bus_len=$(lspci -D | grep -c -i -e '00\.4.*Chelsio'| awk '{print $1}')
adaptype=$(lspci | grep -i -e '00\.4.*Chelsio'| awk '{print $7}')

function getbusid
{
	declare -a bus_list
	declare -a adap_list
	bcid=0
	adid=0
	if [[ $bus_len -gt 1 ]] ; then
		header
		for buss in $bus_ids ; do bcid=` expr $bcid + 1 ` ; bus_list[bcid]=$buss ; done
		for adapss in $adaptype ; do adid=` expr $adid + 1 ` ; adap_list[adid]=$adapss ; done
		echo "$bus_len Chelsio adapters are present in the machine"
		echo -e "Please select a specific adapter from list below:\n"
		bcid=0
		for i in ${bus_list[*]}; do
			bcid=`expr $bcid + 1 `
			echo "$bcid - ${bus_list[$bcid]} - ${adap_list[$bcid]}"
		done
		echo "a - Collect logs for all the above adapters"
		echo "x - Exit"
		while [[ 1 ]] ; do
			echo 
			read -p "Please enter a value: " bus
			case $bus in
				a) fbusid=${bus_list[*]}
				   break
				;;
				x) exit 0 
				;;
				[1-9]) fbusid=${bus_list[$bus]}
				       break
				;;
				*) echo "Please Enter a valid option."
			esac 
		done
	else
		fbusid=$bus_ids
	fi
	
}
if [[ -z $fbusid ]]; then
	getbusid
fi

if [[ -z $fbusid ]]; then
	echo -e "\n\tChelsio card not found\n"
	exit 0
fi

function is_driver_loaded
{
	local driver res

	driver="$1"
	res=$(lsmod | grep $driver)
	if [[ $res == "" ]];then
		echo 0
	else
		echo 1
	fi
}

function getfullbuspath
{
	for fbuss in $fbusid ; do
		fbid=`expr $fbid + 1 `
		fbuspath[fbid]=/sys/bus/pci/devices/${fbuss}
		if [[ -f ${fbuspath[fbid]}/vendor ]];then
			vendor=$(cat ${fbuspath[fbid]}/vendor)
			if ! [[ $vendor -eq "0x1425" ]];then
				echo -e "\n\t\"$fbuss\" is not chelsio Bus\n"
				exit 0
			fi
		else
			echo -e "\n\t\"${fbuspath[fbid]}/vendor\" not found: [May be invalid Bus]\n"
			exit 0
		fi
	done
}
getfullbuspath

function print_once
{
	if [[ -z "$global_print_once" ]]; then
		echo "$1" "$2"
	fi
}

function writelog
{
	echo $1 >> $logfile
}

function printhead
{
	writelog ""
	writelog "#######################################" 
	writelog "####$1"
	writelog "#######################################"
}

function printhead2
{
	writelog "###############$1###############"
}

function cmdlog
{
	local cmd

	writelog ""
	cmd="$1"
	printhead2 "$cmd"
	if [[ $2 -eq 1 ]] ; then
		$cmd | tee -a $logfile
	else
		$cmd >> $logfile
	fi
	sync
}

function get_mem_region_start
{
	local memtype memtype_region memtype_base
	local entity region base

	entity="$1"
	memtype="$2"
	region="$(grep -i "$entity" $debugfs_path/$driver/$busp/meminfo)"
	base=${region%-*}  # Get everything before -
	base=${base#*:}    # Get everything after :

	###
	# Get base relative to @memtype (i.e. EDC*/MC* start)
	###
	memtype_region="$(grep -i "$memtype" $debugfs_path/$driver/$busp/meminfo)"
	memtype_base=${memtype_region%-*}
	memtype_base=${memtype_base#*:}

	echo $(($base - $memtype_base))
}

function get_mem_region_end
{
	local memtype memtype_region memtype_base
	local entity region base

	entity="$1"
	memtype="$2"
	region="$(grep -i "$entity" $debugfs_path/$driver/$busp/meminfo)"
	end=${region#*-}   # Get everything after -
	end=${end%[*}      # Get everything before [

	###
	# Get end relative to @memtype (i.e. EDC*/MC* start)
	###
	memtype_region="$(grep -i "$memtype" $debugfs_path/$driver/$busp/meminfo)"
	memtype_base=${memtype_region%-*}
	memtype_base=${memtype_base#*:}

	echo $(($end - $memtype_base))
}

function round_up
{
	local x y

	x="$1"
	y="$2"
	echo $((($x + $y - 1) / $y * $y))
}

function round_down
{
	local x y

	x="$1"
	y="$2"
	echo $((($x / $y) * $y))
}

function get_debugfs_mc_entity
{
	local tx_payload_base tx_payload_end
	local rx_payload_base rx_payload_end
	local src_debugfs_path src_zero_path
	local entity base end size rem_size
	local chunk_size blk_size count
	local ddcmd src_path dst_path
	local i j k cur_off cur_end
	local cpu_start ncpu

	entity="$1"

	# Get mc start and end
	base=$(get_mem_region_start "$entity" "$entity")
	end=$(get_mem_region_end "$entity" "$entity")
	size=$(($end - $base + 1))

	# Fill dd command parameters
	chunk_size=$((256 * 1024 * 1024)) # 256 MB
	blk_size=$((32 * 1024 * 1024)) # 32 MB
	count=$(($chunk_size / $blk_size))
	src_debugfs_path="${debugfs_path}/$driver/${busp}/${entity}"
	src_zero_path="/dev/zero"
	dst_path="${extract_debugfs_dir}/$driver"

	# Get number of cpus.  Max 8 needed per adapter.
	cpu_start="$3"
	ncpu="$4"

	# Get TX and RX Payload base and end
	tx_payload_base=$(get_mem_region_start "Tx payload" "$entity")
	tx_payload_end=$(get_mem_region_end "Tx payload" "$entity")
	rx_payload_base=$(get_mem_region_start "Rx payload" "$entity")
	rx_payload_end=$(get_mem_region_end "Rx payload" "$entity")

	###
	# Round up payload base to @chunk_size and round down
	# payload end to @chunk_size.  Only full chunks will
	# be skipped.
	###
	tx_payload_base=$(round_up $tx_payload_base $chunk_size)
	tx_payload_end=$(round_down $tx_payload_end $chunk_size)
	rx_payload_base=$(round_up $rx_payload_base $chunk_size)
	rx_payload_end=$(round_down $rx_payload_end $chunk_size)

	# Distribute work across cpus
	rem_size=$size
	j=0
	while [ $rem_size -gt 0 ]; do
		for i in `seq 0 $(($ncpu - 1))`; do
			cur_off=$(($blk_size * $count * $j))
			src_path="$src_debugfs_path"
			if [[ -z $cudbgpayload ]]; then
				if [[ $cur_off -ge $tx_payload_base && $(($cur_off + $chunk_size)) -le $tx_payload_end  ]]; then
					# Fill Payload full chunk with zero
					src_path="$src_zero_path"
				fi
				if [[ $cur_off -ge $rx_payload_base && $(($cur_off + $chunk_size)) -le $rx_payload_end ]]; then
					# Fill Payload full chunk with zero
					src_path="$src_zero_path"
				fi
			fi
			ddcmd="$DD_BIN if=$src_path of=$dst_path/${entity}_task_$j bs=$blk_size count=$count skip=$(($count * $j))"
			k=$(($i+$cpu_start))
			printhead2 "taskset $((1<<$k)) $ddcmd"
			taskset $((1<<$k)) $ddcmd > /dev/null 2>&1 &
			j=$(($j + 1))
			rem_size=$(($rem_size - $chunk_size))
			if [[ $rem_size -le 0 ]]; then
				break
			fi
		done
		wait
	done
	chmod 444 ${dst_path}/${entity}_task_*
}

function get_debugfs_mc
{
	local extract_debugfs_dir
	local cur_cpu ncpu
	local driver busp
	local entity
	local cmd

	entity="$1"
	driver="$2"
	busp="$3"
	cur_cpu="$4"
	ncpu="$5"

	extract_debugfs_dir=$debugfs_dir/$busp
	if ! [[ -d $extract_debugfs_dir/$driver ]];then
		mkdir -p $extract_debugfs_dir/$driver
	fi

	if [[ -f $debugfs_path/$driver/$busp/$entity ]];then
		if [[ ! -z $DD_BIN ]]; then
			get_debugfs_mc_entity "$entity" "$extract_debugfs_dir" "$cur_cpu" "$ncpu"
			return 0
		fi
	fi
	return 1
}

function get_debugfs_entity_flash
{
	local extract_debugfs_dir
	local entity entity_file
	local driver busp cmd
	local block_size

	entity="$1"
	driver="$2"
	busp="$3"
	block_size=$((2 * 1024 * 1024))

	extract_debugfs_dir=$debugfs_dir/$busp
	if ! [[ -d $extract_debugfs_dir/$driver ]];then
		mkdir -p $extract_debugfs_dir/$driver
	fi

	if [[ -f $debugfs_path/$driver/$busp/$entity ]];then
		entity_file=$extract_debugfs_dir/$driver/$entity
		if [[ ! -z $DD_BIN ]]; then
			cmd="$DD_BIN if=$debugfs_path/$driver/$busp/$entity of=$entity_file bs=$block_size count=1 skip=0"
		else
			cmd="cp $debugfs_path/$driver/$busp/$entity $entity_file"
		fi
		cmdlog "$cmd" 1 > /dev/null 2>&1
		chmod 444 $entity_file
		return 0
	fi
	return 1
}

function get_debugfs_entity
{
	local extract_debugfs_dir
	local entity entity_file
	local block_size
	local driver cmd
	local busp

	entity=$1
	driver=$2
	busp="$3"
	block_size=$((8 * 1024 * 1024))

	extract_debugfs_dir=$debugfs_dir/$busp
	if ! [[ -d $extract_debugfs_dir/$driver ]];then
		mkdir -p $extract_debugfs_dir/$driver
	fi

	if [[ -f $debugfs_path/$driver/$busp/$entity ]];then
		entity_file=$extract_debugfs_dir/$driver/$entity
		if [[ ! -z $DD_BIN ]]; then
			cmd="$DD_BIN if=${debugfs_path}/${driver}/${busp}/${entity} of=${entity_file} bs=$block_size"
		else
			cmd="cp $debugfs_path/$driver/$busp/$entity $entity_file"
		fi
		cmdlog "$cmd" 1 > /dev/null 2>&1
		chmod 444 $entity_file
		return 0
	fi
	return 1
}

function get_toe_intfs
{
	if [[ -f $offload_devices_Path ]];then
		toe_eths=$(cat /proc/net/offload/devices | awk -F " " '/.*Chelsio-T4.*/ {print $4}')
		toe_eths=$(echo $toe_eths | tr " " "\n")
		for eth in $toe_eths
		do
			busid=$(ethtool -i $eth | awk -F " " '/bus-info.*/ {print $2}')
			toex=$(cat /proc/net/offload/devices | grep $eth | awk -F " " '/.*/ {print $1}')
			toe[$busid]=$toex
		done
	fi
}

###
# Entities that need extra time or formatting for collection and
# hence should be collected last
###
declare -a skip_entities=(
	'mc0'
	'mc1'
)

###
# Entities that can be safely collected via cudbg
###
declare -a safe_entities=(
	'regdump'
	'rss_pf_config'
	'rss_key'
	'rss_vf_config'
	'rss_config'
	'pathmtu'
	'swstate'
	'wtp'
	'tcpstats'
	'tperrstats'
	'fcoestats'
	'rdmastats'
	'tpindirect'
	'sgeindirect'
	'cplstats'
	'ddpstats'
	'wcstats'
	'lbstats'
	'meminfo'
	'clk'
	'macstats'
	'pcieindirect'
	'full'
	'txrate'
	'tidinfo'
	'pcieconfig'
	'dumpcontext'
	'maindirect'
	'ulptxla'
	'hmaindirect'
	'rss'
	'pmindirect'
	'mpstcam'
	'vpddata'
	'letcam'
	'upcimindirect'
	'pbttables'
)

###
# Entities that have side effects in runtime and hence should be
# tried to collect via cxgb4 debugfs first and then fall back to
# cudbg if failed.
#
# Key (subscript) refers to debugfs file name
# Value refers to cudbg entity name
###
declare -A side_effect_entities
side_effect_entities['devlog']="devlog"
side_effect_entities['cim_la']="cimla"
side_effect_entities['cim_ma_la']="cimmala"
side_effect_entities['cim_qcfg']="cimqcfg"
side_effect_entities['ibq_tp0']="ibqtp0"
side_effect_entities['ibq_tp1']="ibqtp1"
side_effect_entities['ibq_ulp']="ibqulp"
side_effect_entities['ibq_sge0']="ibqsge0"
side_effect_entities['ibq_sge1']="ibqsge1"
side_effect_entities['ibq_ncsi']="ibqncsi"
side_effect_entities['obq_ulp0']="obqulp0"
side_effect_entities['obq_ulp1']="obqulp1"
side_effect_entities['obq_ulp2']="obqulp2"
side_effect_entities['obq_ulp3']="obqulp3"
side_effect_entities['obq_sge']="obqsge"
side_effect_entities['obq_ncsi']="obqncsi"
side_effect_entities['edc0']="edc0"
side_effect_entities['edc1']="edc1"
side_effect_entities['pm_stats']="pmstats"
side_effect_entities['hw_sched']="hwsched"
side_effect_entities['ulprx_la']="ulprxla"
side_effect_entities['tp_la']="tpla"
side_effect_entities['cim_pif_la']="cimpifla"
side_effect_entities['obq_sge_rx_q0']="obq_sge_rx_q0"
side_effect_entities['obq_sge_rx_q1']="obq_sge_rx_q1"
side_effect_entities['cctrl']="cctrl"

function get_cudbg_entity
{
	local debugfs_entity mcregex
	local cur_cpu ncpu
	local busp rc

	debugfs_entity="$1"
	busp="$2"
	mcregex="^mc"

	if [[ $debugfs_entity =~ $mcregex ]]; then
		cur_cpu="$3"
		ncpu="$4"
		get_debugfs_mc "$debugfs_entity" "cxgb4" "$busp" "$cur_cpu" "$ncpu"
	else
		get_debugfs_entity $debugfs_entity "cxgb4" "$busp"
	fi

	rc=$?
	if [[ $rc == 1 ]]; then
		return 1
	fi
	return 0
}

function collect_cudbg_entities
{
	local collect_entity_list entity_list
	local cudbg_busp busp buspath
	local skip_str safe_str
	local ch_intfs ch_intf
	local pcie_path
	local cmd res

	buspath="$1"
	busp=$(basename $buspath)
	cudbgbusp=$(echo $busp | sed s/'\w*$'//)
	cudbgbusp+=$cudbgmbox

	pcie_path=$(dirname $buspath)
	pcie_path+="/$cudbgbusp/"

	print_once "-e" "\n-------------------------------------------------"
	print_once "Collecting cudbg entities"
	###
	# Convert array elements to comma separated string.
	###
	skip_str=$(IFS=,; echo "${skip_entities[*]}")
	safe_str=$(IFS=,; echo "${safe_entities[*]}")

	###
	# Collect some entities from debugfs if cxgb4 is loaded.
	# Else, collect from cudbg.
	###
	res=$(is_driver_loaded cxgb4)
	if [[ $res == 0 ]]; then
		cmdlog "$CUDBG_BIN --collect all $pcie_path ${cudbglog}_${cudbgbusp}.log --skip $skip_str $cudbgpayload" 1 > /dev/null 2>&1
		print_once "-e" "\n-------------------------------------------------"
		return
	fi

	# get all chelsio inteface according to busp
	ch_intfs=$(get_ch_intfs $busp)
	# one interface is enought for getting qdesc for each Bus
	ch_intf=$(echo $ch_intfs | awk '{print $1}')
	if [[ $ch_intf == "" ]];then
		echo "Chelsio Interfaces for $busp not found"
		echo -e "-------------------------------------------------\n"
		return
	fi

	cmd="ethtool -W $ch_intf 0x2"
	printhead2 "$cmd"
	$cmd > /dev/null 2>&1
	res=$?
	if [[ $res == 0 ]]; then
		cmd="ethtool -w $ch_intf data ${cudbglog}_${cudbgbusp}.log"
		printhead2 "$cmd"
		$cmd > /dev/null 2>&1
		res=$?
		if [[ $res == 0 ]]; then
			print_once "-e" "\n-------------------------------------------------"
			return
		fi
	fi

	for se_entity in ${!side_effect_entities[@]}; do
		res=$(get_cudbg_entity $se_entity "$busp")
		res=$?
		if [[ $res == 1 ]]; then
			collect_entity_list+=",${side_effect_entities[$se_entity]}"
		fi
	done

	###
	# Collect the safe entities and rest of the entities (i.e. those that
	# failed to be collected from debugfs) via cudbg.
	###
	entity_list=$safe_str
	entity_list+=$collect_entity_list

	cmdlog "$CUDBG_BIN --collect $entity_list $pcie_path ${cudbglog}_${cudbgbusp}.log --skip $skip_str $cudbgpayload" 1 > /dev/null 2>&1
	print_once "-e" "\n-------------------------------------------------"
}

function collect_cudbg_edc
{
	local collect_entity_list
	local busp cudbgbusp
	local cur_cpu ncpu
	local pcie_path
	local eths
	local res

	eths="$1"

	busp=$(basename $eths)
	cudbgbusp=$(echo $busp | sed s/'\w*$'//)
	cudbgbusp+=$cudbgmbox

	pcie_path=$(dirname $eths)
	pcie_path+="/$cudbgbusp/"

	print_once "-e" "\n-------------------------------------------------"
	print_once "-e" "Collecting edc logs\n"

	###
	# Collect mc entities from debugfs if cxgb4 is loaded.
	# Else, collect from cudbg.
	###
	res=$(is_driver_loaded cxgb4)
	if [[ $res == 0 ]]; then
		cmdlog "$CUDBG_BIN --collect edc0,edc1 $pcie_path ${cudbglog}_${cudbgbusp}_edc.log $cudbgpayload" 1 > /dev/null 2>&1
		print_once "-e" "-------------------------------------------------\n"
		return
	fi

	res=$(get_cudbg_entity "edc0" "$busp")
	res=$?
	if [[ $res == 1 ]]; then
		collect_entity_list+="edc0"
	fi

	res=$(get_cudbg_entity "edc1" "$busp")
	res=$?
	if [[ $res == 1 ]]; then
		collect_entity_list+="edc1"
	fi

	if ! [[ -z $collect_entity_list ]]; then
		cmdlog "$CUDBG_BIN --collect $collect_entity_list $pcie_path ${cudbglog}_${cudbgbusp}_edc.log $cudbgpayload" 1 > /dev/null 2>&1
	fi

	print_once "-e" "-------------------------------------------------\n"
}

function collect_cudbg_mc
{
	local collect_entity_list
	local busp cudbgbusp
	local cur_cpu ncpu
	local mc cudbg_mc
	local pcie_path
	local eths
	local res

	eths="$1"
	mc="$2"
	cudbg_mc="$mc"
	cur_cpu="$3"
	ncpu="$4"

	busp=$(basename $eths)
	cudbgbusp=$(echo $busp | sed s/'\w*$'//)
	cudbgbusp+=$cudbgmbox

	pcie_path=$(dirname $eths)
	pcie_path+="/$cudbgbusp/"

	###
	# For T6, there is only one "mc" in debugfs.
	# Cudbg internally uses "mc0" entity to collect this "mc" in debugfs.
	# So, translate to Cudbg's internal format.
	###
	if [[ $mc == "mc" ]]; then
		cudbg_mc="mc0"
	fi

	print_once "-e" "\n-------------------------------------------------"
	print_once "-e" "Collecting mc logs\n"

	###
	# Collect mc entities from debugfs if cxgb4 is loaded.
	# Else, collect from cudbg.
	###
	res=$(is_driver_loaded cxgb4)
	if [[ $res == 0 ]]; then
		cmdlog "$CUDBG_BIN --collect $cudbg_mc $pcie_path ${cudbglog}_${cudbgbusp}_${mc}.log $cudbgpayload" 1 > /dev/null 2>&1
		print_once "-e" "-------------------------------------------------\n"
		return
	fi

	res=$(get_cudbg_entity "$mc" "$busp" "$cur_cpu" "$ncpu")
	res=$?
	if [[ $res == 1 ]]; then
		collect_entity_list="$cudbg_mc"
	fi

	if ! [[ -z $collect_entity_list ]]; then
		cmdlog "$CUDBG_BIN --collect $cudbg_mc $pcie_path ${cudbglog}_${cudbgbusp}_${mc}.log $cudbgpayload" 1 > /dev/null 2>&1
	fi

	print_once "-e" "-------------------------------------------------\n"
}

function collect_cudbg_mc_entities
{
	local card card_type
	local cur_cpu ncpu
	local buspath

	buspath="$1"
	card=$($CUDBG_BIN --debug vpddata $buspath | grep MN | awk '{print $2'})
	card_type=${card:1:1}

	cur_cpu="$2"
	ncpu="$3"
	###
	# If it's a T6 card, collect "mc", if it exists.
	# Otherwise, collect "mc0" and "mc1", if they exist.
	###
	if [[ $card_type == "6" ]]; then
		collect_cudbg_mc $buspath "mc" "$cur_cpu" "$ncpu"
	else
		collect_cudbg_mc $buspath "mc0" "$cur_cpu" "$ncpu"
		collect_cudbg_mc $buspath "mc1" "$cur_cpu" "$ncpu"
	fi
}

PROTO_ETH="Ethernet"
PROTO_TOE="TOE"
PROTO_CTRL="Control"
PROTO_RDMA_CTRL="RDMA-Control"
PROTO_RDMA_CIQ="RDMA-CIQ"
PROTO_RDMA_CPL="RDMA-CPL"
PROTO_CRYPTO="Crypto"
QID_TXQ="TxQ"
QID_RSPQ="RspQ"
QID_FL="FL"
function collect_qdesc_utils
{
	local qid qids qidtype qtype
	local file_dir qinfo_file
	local qsizesarr qsizes
	local qdesc qdesc_file
	local proto_type
	local ch_intfs
	local cmd
	local i

	ch_intfs=$1
	qinfo_file=$2
	proto_type=$3
	qidtype=$4

	if [[ $proto_type == $PROTO_ETH ]] && [[ $qidtype == $QID_TXQ ]];then
		qtype="eth"
	elif [[ $proto_type == $PROTO_ETH ]] && [[ $qidtype == $QID_RSPQ ]];then
		qtype="rsp"
	elif [[ $proto_type == $PROTO_ETH ]] && [[ $qidtype == $QID_FL ]];then
		qtype="fl"
	elif [[ $proto_type == $PROTO_TOE ]] && [[ $qidtype == $QID_TXQ ]];then
		qtype="ofld"
	elif [[ $proto_type == $PROTO_TOE ]] && [[ $qidtype == $QID_RSPQ ]];then
		qtype="rsp"
	elif [[ $proto_type == $PROTO_TOE ]] && [[ $qidtype == $QID_FL ]];then
		qtype="fl"
	elif [[ $proto_type == $PROTO_CRYPTO ]] && [[ $qidtype == $QID_TXQ ]];then
		qtype="crypto"
	elif [[ $proto_type == $PROTO_CRYPTO ]] && [[ $qidtype == $QID_RSPQ ]];then
		qtype="rsp"
	elif [[ $proto_type == $PROTO_CRYPTO ]] && [[ $qidtype == $QID_FL ]];then
		qtype="fl"
	elif [[ $proto_type == $PROTO_CTRL ]];then
		qtype="ctrl"
		qidtype="TxQ"
	elif [[ $proto_type == $PROTO_RDMA_CTRL ]];then
		# replacing "RDMA-Control" to "RDMA Control" as sge_qinfo
		proto_type=$(echo $proto_type | sed 's/-/ /g')
		qtype="ctrl"
		qidtype="TxQ"
	elif [[ $proto_type == $PROTO_RDMA_CIQ ]] || [[ $proto_type == $PROTO_RDMA_CPL ]];then
		qtype="rsp"
		qidtype="RspQ"
	else
		echo -e "\n\tWrong Protocol provided\n"
		return
	fi

	if [[ $qidtype == "" ]];then
		echo "Q ID type not found"
		return
	fi

	# finding q IDs according to proto type like "Ethernet", "TOE" qtype like Txq, RspQ, FL
	qids=$(cat $qinfo_file | awk 'BEGIN{RS="\nQ"} /  '"$proto_type"'/ {print "Q"$0}' | awk '/'"$qidtype"' ID/ {print $3" "$4" "$5" "$6}')
	if [[ $qids == "" ]];then
		echo "No Queue found for \"$proto_type\" with Qtype \"$qtype\""
		return
	fi

	qsizes=$(cat $qinfo_file | awk 'BEGIN{RS="\nQ"} /  '"$proto_type"'/ {print "Q"$0}' | awk '/'"$qidtype"' size/ {print $3" "$4" "$5" "$6}')
	qsizesarr=(${qsizes// / })
	i=0
	# replacing proto type like "RDMA Control", "RDMA-CIQ" to "RDMA_Control" "RDMA_CIQ" for dir
	proto_type=$(echo $proto_type | sed 's/ /_/g' | sed 's/-/_/g')
	mkdir -p $qdesc_dir/$proto_type/$qtype
	file_dir=$qdesc_dir/$proto_type/$qtype
	for qid in $qids; do
		cmd="cxgbtool $ch_intfs qdesc $qtype $qid 0 ${qsizesarr[i]}"
		qdesc=$($cmd)
		qdesc_file=$file_dir/qid_$qid
		printf "%s\n" "$qdesc" > $qdesc_file 
		i=$((i+1))
	done

}

function is_intfs_for_bus
{
	local eth_bus intfs busp

	busp=$1
	intfs=$2

	# removing . and : from bus string
	busp=$(echo $busp | sed -e 's/\.//g' | sed -e 's/\://g')

	eth_bus=$(ethtool  -i $intfs | awk '/bus-info/ {print $2}')
	eth_bus=$(echo $eth_bus | sed -e 's/\.//g' | sed -e 's/\://g')
	if [[ "$eth_bus" == "$busp" ]];then
		echo "1"
		return
	fi

	echo "0"
}

function get_ch_intfs
{
	local allintfs ch_intfs intfs
	local vendor_id busp
	local ret

	busp=$1	
	allintfs=$(ls /sys/class/net)
	ch_intfs=()
	for intfs in $allintfs;do
		if [[ -f /sys/class/net/$intfs/device/vendor ]];then
			vendor_id=$(cat /sys/class/net/$intfs/device/vendor)
			if [[ $vendor_id == "0x1425" ]];then
				ret=$(is_intfs_for_bus $busp $intfs)
				if [[ $ret == "1" ]];then
					ch_intfs+=("$intfs")
				fi
			fi
		fi
	done

	echo ${ch_intfs[@]}
}

function is_any_intfs_up
{
	local ch_intfs intf
	local ret
	ch_intfs=$1

	for intf in $ch_intfs;do
		# if intf is up then /sys/class/net/$intf/carrier file will 
		# have some data "0" or 1 otherwise not
		ret=$(cat /sys/class/net/$intf/carrier 2>/dev/null)
		if [[ $ret != "" ]];then
			echo "1"
			return
		fi
	done

	echo "0"
}

function collect_qdesc
{
	local ch_intfs ch_intf busp
	local qinfo_file
	local cxgbtool
	local ret

	busp="$1"
	print_once "-e" "\n-------------------------------------------------"
	print_once "Collecting Queue descriptors"

	res=$(is_driver_loaded cxgb4)
	if [[ $res == 0 ]]; then
		print_once "cxgb4 driver is not loaded"
		print_once "-e" "-------------------------------------------------"
		return
	fi

	cxgbtool=$(which cxgbtool 2> /dev/null)
	if [[ $cxgbtool == "" ]];then
		print_once "-e" "cxgbtool is not installed"
		print_once "-e" "-------------------------------------------------\n"
		return
	fi

	# get all chelsio inteface according to busp
	ch_intfs=$(get_ch_intfs $busp)
	res=$(is_any_intfs_up $ch_intfs)
	if [[ $res == "0" ]];then
		echo "Chelsio Interface is not Up"
		echo -e "-------------------------------------------------\n"
		return
	fi

	# one interface is enought for getting qdesc for each Bus
	ch_intf=$(echo $ch_intfs | awk '{print $1}')

	if [[ $ch_intf == "" ]];then
		echo "chelsio interface not found"
		echo -e "-------------------------------------------------\n"
		return
	fi

	###
	# See if cxgbtool's ioctls have been implemented in the loaded
	# cxgb4 driver.  Fetch driver version via ethtool.  If it has
	# 'ko' in it, then the loaded driver is inbox driver and hence
	# cxgbtool is not compatible. Otherwise, it is outbox driver
	# and hence cxgbtool is compatible.
	###
	res=$(ethtool -i $ch_intf | grep 'version' | awk '{print $2}' | grep 'ko')
	if ! [[ -z $res ]]; then
		print_once "-e" "Inbox cxgb4 driver loaded"
		print_once "-e" "-------------------------------------------------\n"
		return
	fi

	qinfo_file="/sys/kernel/debug/cxgb4/$busp/sge_qinfo"
	if ! [[ -f $qinfo_file ]]; then
		echo -e "/sys/kernel/debug/cxgb4/$busp/sge_qinfo file not found"
		echo -e "-------------------------------------------------\n"
		return
	fi

	mkdir -p $qdesc_dir
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_ETH $QID_TXQ
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_ETH $QID_RSPQ
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_ETH $QID_FL
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_TOE $QID_TXQ
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_TOE $QID_RSPQ
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_TOE $QID_FL
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_CTRL 
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_RDMA_CTRL 
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_RDMA_CIQ 
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_RDMA_CPL 
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_CRYPTO $QID_TXQ 
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_CRYPTO $QID_RSPQ
	collect_qdesc_utils $ch_intf $qinfo_file $PROTO_CRYPTO $QID_FL
	print_once "-e" "\n-------------------------------------------------"
}

function collect_toe_sys_files
{
	local extract_toe_dir
	local busp cmd
	local res

	busp="$1"
	print_once "-e" "\n-------------------------------------------------"
	print_once "Collecting toe sys files"

	res=$(is_driver_loaded "t4_tom")
	if [[ $res == 0 ]];then
		print_once "t4_tom driver is not loaded"
		print_once "-e" "-------------------------------------------------"
		return
	fi

	if [[ ${#toe[@]} == 0 ]];then
		print_once "No chelsio offload devices found"
		return
	fi

	if ! [[ -d $proc_sys/toe/${toe[$busp]}_tom ]]; then
		echo -e "sys files not found for bus \"$busp\" in \"$proc_sys/\"\n"
		return
	fi

	extract_toe_dir=$toe_dir/${toe[$busp]}_tom_${busp}
	mkdir -p $extract_toe_dir
	cmd="cp -r $proc_sys/toe/${toe[$busp]}_tom/*  $extract_toe_dir"
	$cmd
	print_once "-e" "-------------------------------------------------"
}

function collect_cxgb4_debugfs
{
	local i busp
	local res

	busp="$1"
	print_once "-e" "\n-------------------------------------------------"
	print_once "Collecting cxgb4 debugfs"
	res=$(is_driver_loaded cxgb4)
	if [[ $res == 0 ]]; then
		print_once "cxgb4 driver is not loaded"
		print_once "-e" "-------------------------------------------------"
		return
	fi

	for i in {0..7};do
		get_debugfs_entity "mbox$i" "cxgb4" "$busp"
	done

	get_debugfs_entity "mboxlog" "cxgb4" "$busp"

	get_debugfs_entity "sge_qinfo" "cxgb4" "$busp"

	get_debugfs_entity "qstats" "cxgb4" "$busp"

	get_debugfs_entity "smt" "cxgb4" "$busp"

	get_debugfs_entity "blocked_fl" "cxgb4" "$busp"

	get_debugfs_entity "clip_tbl" "cxgb4" "$busp"

	get_debugfs_entity "devlog_level" "cxgb4" "$busp"

	get_debugfs_entity "dmabuf" "cxgb4" "$busp"

	get_debugfs_entity "filters" "cxgb4" "$busp"

	get_debugfs_entity_flash "flash" "cxgb4" "$busp"

	get_debugfs_entity "hash_filters" "cxgb4" "$busp"

	get_debugfs_entity "inject_err" "cxgb4" "$busp"

	get_debugfs_entity "intr_cnt" "cxgb4" "$busp"

	get_debugfs_entity "intr_holdoff" "cxgb4" "$busp"

	get_debugfs_entity "l2t" "cxgb4" "$busp"

	get_debugfs_entity "sensors" "cxgb4" "$busp"

	get_debugfs_entity "trace0" "cxgb4" "$busp"

	get_debugfs_entity "trace1" "cxgb4" "$busp"

	get_debugfs_entity "trace2" "cxgb4" "$busp"

	get_debugfs_entity "trace3" "cxgb4" "$busp"

	get_debugfs_entity "uld" "cxgb4" "$busp"

	get_debugfs_entity "use_backdoor" "cxgb4" "$busp"

	get_debugfs_entity "tls" "cxgb4" "$busp"

	get_debugfs_entity "crypto" "cxgb4" "$busp"

	get_debugfs_entity "trace_rss" "cxgb4" "$busp"

	print_once "-e"  "-------------------------------------------------"
}

function collect_iw_cxgb4_debugfs
{
	local busp
	local res

	busp="$1"
	print_once "-e" "\n-------------------------------------------------"
	print_once "Collecting iw_cxgb4 debugfs"
	res=$(is_driver_loaded "iw_cxgb4")
	if [[ $res == 0 ]]; then
		print_once "iw_cxgb4 driver is not loaded"
		print_once "-e" "-------------------------------------------------"
		return
	fi

	get_debugfs_entity "eps" "iw_cxgb4" "$busp"

	get_debugfs_entity "fids" "iw_cxgb4" "$busp"

	get_debugfs_entity "qps" "iw_cxgb4" "$busp"

	get_debugfs_entity "stags" "iw_cxgb4" "$busp"

	get_debugfs_entity "stats" "iw_cxgb4" "$busp"
	print_once "-e" "-------------------------------------------------"
}

function collect_csiostor_pf5_debugfs
{
	local driver busp
	local res

	busp="$1"
	driver="csiostor"
	print_once "-e" "\n-------------------------------------------------"
	print_once "Collecting $driver pf 5 debugfs"
	res=$(is_driver_loaded $driver)
	if [[ $res == 0 ]]; then
		print_once "$driver driver is not loaded"
		print_once "-e" "-------------------------------------------------"
		return
	fi

	get_debugfs_entity "dump_vaddr" $driver "$busp"
	get_debugfs_entity "hw" $driver "$busp"
	get_debugfs_entity "hw_stats" $driver "$busp"
	get_debugfs_entity "iscsi_sessions" $driver "$busp"
	get_debugfs_entity "sge_queue_entry" $driver "$busp"
	get_debugfs_entity "sge_queues" $driver "$busp"
	get_debugfs_entity "trace_buf" $driver "$busp"

	print_once "-e" "-------------------------------------------------"
}

function collect_csiostor_pf6_debugfs
{
	local driver busp
	local res

	busp="$1"
	driver="csiostor"
	print_once "-e" "\n-------------------------------------------------"
	print_once "Collecting $driver pf 6 debugfs"
	res=$(is_driver_loaded $driver)
	if [[ $res == 0 ]]; then
		print_once "$driver driver is not loaded"
		print_once "-e" "-------------------------------------------------"
		return
	fi

	get_debugfs_entity "fcfs" $driver "$busp"
	get_debugfs_entity "lnodes" $driver "$busp"
	get_debugfs_entity "lnodes_stats" $driver "$busp"
	get_debugfs_entity "rnodes" $driver "$busp"
	get_debugfs_entity "rnodes_stats" $driver "$busp"

	print_once "-e" "-------------------------------------------------"
}

function change_pf
{
	local extract_debugfs_dir busp pf

	busp="$2"
	if [[ $# -eq 1 ]] ; then
		pf=$1
	else
		pf=4
	fi 

	busp=$(echo $busp | sed s/'\w*$'//)$pf
	extract_debugfs_dir=$debugfs_dir/$busp
	mkdir -p $extract_debugfs_dir
	echo "$busp"
}

echo "Collecting OS debug logs at $logfile"
echo "This may take sometime, Please Wait.."
echo > $logfile

if [[ $bus_len -eq 0 ]] ; then
	writelog "No chelsio Adapters found"
	adaptype=""
fi

ethinterfaces=$(ifconfig -a | awk '/^[a-z]/ { print $1 } ' | awk -F ":" '{print $1}')

chcount=0
declare -a chintf #Array to store all chelsio interfaces
for chbusinf in ${fbusid[*]} ; do
	for intf in $ethinterfaces ; do
		if [[ $intf == "lo" ]] ; then
			continue
		fi
		chhwid=$(ethtool -i $intf | grep -c -E $chbusinf 2>/dev/null)
		if [ $chhwid -gt 0 ] ; then
			chcount=` expr $chcount + 1 `
			chint[chcount]=$intf
		fi
	done
done

CUDBG_BIN=$(which cudbg_app 2>/dev/null)
if [[ $? -ne 0 ]] ; then 
	CUDBG_BIN=${PWD}/bin/cudbg_app
	if [[ ! -f $CUDBG_BIN ]] ; then
		CUDBG_BIN=${PWD}/cudbg_app
		if [[ ! -f $CUDBG_BIN ]] ; then
			echo -e "\nChelsio \"cudbg_app\" utility is needed to collect adapter debug logs."
			echo 	"The cudbg_app utility can be installed using Chelsio Unified wire source package."
			exit 3
		fi
	fi
fi

DD_BIN="$(which dd)"

get_toe_intfs

function collect_debug_entities
{
	local buspath
	local busp

	buspath="$1"
	busp=$(basename $buspath)

	# collecting debugfs from pf 4
	busp=$(change_pf 4 "$busp")

	collect_cudbg_entities "$buspath"

	collect_cudbg_edc "$buspath"

	collect_cxgb4_debugfs "$busp"

	collect_iw_cxgb4_debugfs "$busp"

	collect_toe_sys_files "$busp"

	collect_qdesc "$busp"

	# collecting debugfs from pf 5
	busp=$(change_pf 5 "$busp")
	collect_csiostor_pf5_debugfs "$busp"

	# collecting debugfs from pf 6
	busp=$(change_pf 6 "$busp")
	collect_csiostor_pf6_debugfs "$busp"
}

echo -e "\nCollecting Adapter logs for bus id's ${fbusid[*]} using CUDBG... \n"
for buspath in ${fbuspath[*]} ; do
	if ! [[ -d $debugfs_path ]]
	then
		mount none $debugfs_path -t debugfs
	fi

	collect_debug_entities "$buspath" &
	global_print_once=1
done
wait

global_print_once=""
ncpus="$(grep -c ^processor /proc/cpuinfo)"
max_cpu=8
per_adap_cpu=$(($ncpus<$max_cpu?$ncpus:$max_cpu))
cur_cpuid=0
for buspath in ${fbuspath[*]} ; do
	collect_cudbg_mc_entities "$buspath" "$cur_cpuid" "$per_adap_cpu" &
	cur_cpuid=$(($cur_cpuid + $per_adap_cpu))
	if [[ $cur_cpuid -ge $ncpus ]]; then
		cur_cpuid=$(($cur_cpuid - $ncpus))
	fi
	global_print_once=1
done
wait
